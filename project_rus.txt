4COM1042 [Computing Platforms]
Co-design Group Project B
“The Game of TV-Tennis”
Notes
Alex Shafarenko & Steve Hunt, 2016

/-----------------------------------/

---| Страница 1 |---

//Обзор//

Для этого проекта вы будете реализовывать телевизионную игру в теннис.

• Вы внедрили видеодисплей 32x32 и чип кинематического контроллера, который будет
перемещать ракетки и мяч по дисплею, и вы будете использовать набор 7-сегментных
дисплеев для отображения текущих результатов двух игроков.

• Вы также напишете программу, которая предсказывает, куда полетит мяч, и позиционирует
компьютерную ракетку, чтобы отбить его.

TV-tennis - это одно из названий первой когда-либо выпущенной видеоигры (the Game of Pong).
Посмотрите следующее видео, в котором изобретатель Ральф Беринг играет
https://youtu.be/XNRx5hc4gYc
и еще немного истории игры из Смитсоновского
института https://youtu.be/-I73oK9q-jk

В этом проекте мы пытаемся воспроизвести некоторые особенности телевизионного тенниса, а также заставить
компьютер играть в него с человеком как можно более увлекательно.
Мы, конечно, вооружены нашими превосходными знаниями в области вычислительной техники по сравнению с прототипом 1960
-х годов, но также в невыгодном положении из-за довольно грубой технологии моделирования Logisim,
которая не позволяет нам использовать несколько контроллеров bat одновременно и ограничивает
разрешение видео 32x32.

Тем не менее, вполне возможно добиться реалистичного игрового процесса; более того, поскольку
моделирование процессора одинаково простое (и медленное), что необычно, довольно легко создать систему, 
в которой компьютер и человек–игрок одинаково подобраны. Этому также способствует
громоздкость имитируемого джойстика: переместить ракетку
в нужное место на доске непросто, особенно если джойстик был выведен
за пределы датчика.

//Роботизированный игрок//
Новым элементом в нашей игре по сравнению с классической версией является роботизированный игрок:
компьютер, который управляет одной из ракеток.
Компьютер всегда играет правой ракеткой, а левой ракеткой управляет человек с помощью
имитируемого джойстика. Чтобы немного выровнять игру, мы ограничили робота-игрока:

• Компьютер может перемещать ракетку только тогда, когда мяч находится в левой половине экрана
(половина игрока-человека). Как только мяч попадает на правую половину поля, игровой
контроллер (часть оборудования) блокирует правую ракетку.

Таким образом, компьютер должен сделать свои прогнозы и переместить правильную ракетку до того, как мяч окажется в
это половина экрана. Поскольку моделирование выполняется на уровне логического элемента, компьютер работает медленно.
Иногда он будет недостаточно быстр и промахнется мимо мяча.

---| Страница 2 |---

//Возможные расширения//

Несмотря на то, что мы усовершенствовали компьютер, он все равно лучше приспособлен для прогнозирования,
чем игрок-человек, и это может привести к скучной игре. Чтобы сделать это интересным,
в нашей эталонной реализации были введены две расширенные функции, которые вы могли
бы рассмотреть возможность добавления в качестве расширений к базовой системе, как только она заработает:

1. Чтобы сделать его более интересным, контроллер применяет силу рассеивания вертикально, т.е.
случайным образом отбрасывает мяч от цели немного вверх или вниз. Таким образом, траектория не может быть
предсказывается путем построения одной прямой линии, но путем определения узкого диапазона различных
направлений, в которых может двигаться мяч. Это означает, что программа должна работать с мертвой
точки.
Иногда, когда расчет неправильно предсказывает направление, в котором
мяч будет отскакивать, компьютеру может потребоваться изменить положение ракетки более одного раза
во время полета мяча.
В ситуации, когда угол падения довольно крутой, программе необходимо выполнить
больше работы для учета прогнозируемых отражений, и человеку
гораздо легче выиграть очко.

2. Более того, система отсчета включает в себя схему передачи скорости, которая передает
часть импульса ракетки мячу, заставляя мяч “вращаться” с ракетки.
Это изменяет угол отражения и позволяет человеку, хотя и довольно сложно,
атаковать робота крутыми вращающимися выстрелами.

Естественно, нет никаких ожиданий, что вы разработаете какую-либо из этих расширенных функций,
но полезно знать, что они могут быть добавлены в рамках ограничений данной
технологии моделирования и ядра процессора.
Вы не ограничены в том, как вы расширяете систему, как только она заработает. Вы можете
изменить его функциональность или добавить другие расширенные функции по своему усмотрению.

---| Страница 3 |---

//Дизайн//

Этот проект в основном касается аппаратной части. Геймпад состоит из нескольких
компонентов, соединенных довольно простым способом. Один из этих компонентов –
кинематический контроллер, обозначенный на схеме буквой "С", - довольно сложен. Мы оставим
рассмотрение этого компонента напоследок и сначала рассмотрим остальные.

*рисунок*

//Панель дисплея, ракетки и мяч//

У нас есть панель отображения общего назначения, состоящая из 1024 пикселей, расположенных в 32 столбца
по 32 пикселя в каждом. Столбцы пронумерованы 0..31 слева направо, а пиксели в
каждом столбце пронумерованы 0..31 снизу вверх.

Каждый столбец имеет 32-разрядный входной вывод с одним битом на пиксель. Шаблон, отображаемый
столбцом, определяется 32-разрядным шаблоном, который задан на этом выводе (максимумы в шаблоне
включают пиксели, а минимумы отключают пиксели). При правильных входных сигналах эта панель
может отображать любой шаблон размером 32x32 пикселя.

Для ТВ-тенниса нам нужно отобразить 2 ракетки и мяч на простом фоне. Мяч
рисуется в виде одного пикселя, а каждая ракетка рисуется в виде вертикальной линии, состоящей из 3 соседних
пикселей в одном столбце. Мяч может появиться в любом месте экрана, но ракетки могут
появляться только в фиксированных столбцах (левая ракетка в столбце 3 и правая ракетка в столбце 28).
Чтобы отобразить шар, нам нужно включить 1 пиксель из 32 в определенном столбце на экране.

Нам нужно знать столбец (координата x) и строку (координата y), в которых мяч должен
появиться. Чтобы отобразить одну ракетку, мы включаем 3 соседних пикселя из 32 в фиксированном столбце, поэтому
нам просто нужно указать строку (координата y), в которой должен отображаться нижний конец ракетки.
Итак, нам нужны четыре 5-битных числа, чтобы указать положение мяча (ballX, ballY) и
двух ракеток (leftbatY, rightbatY). Они будут поступать от кинематического контроллера.

---| Страница 4 |---

//Видеоподсистема//

Видеоподсистема имеет четыре 5-разрядных входа: ballX, ballY, leftbatY, rightbatY. Панель дисплея
управляется набором из 32 видеочипов, и все четыре из этих входов подключены к каждому
видеочипу. Однако, чтобы уменьшить количество проводов, видеочипы соединены цепочкой.
Чипы расположены в цепочке с Запада на Восток; самый западный чип получает все
входные данные и передает их следующему чипу в цепочке.

Вместо цепочки из 32 отдельных видеочипов мы используем сотовую конструкцию. 8 фишек - это
соединенные вместе, чтобы создать раздел видео. 4 из этих секций затем соединяются цепочкой. 
Проектирование ячеек - это стандартная методика: спроектируйте одну ячейку, добавьте ее в библиотеку схем,
затем создайте схему большего размера, соединив несколько одинаковых ячеек по обычной схеме.

Каждая секция обозначена на принципиальной схеме прямоугольником, содержащим диагональный крест.

//Видеочип//

Каждый видеочип имеет входные контакты ballX, ballY, leftbatY, rightbatY на западной стороне и выходные контакты ballX,
ballY, leftbatY, rightbatY на восточной стороне и битовые шаблоны на каждом из них
проходят через каждый видеочип без изменений.

Каждый видеочип управляет определенным столбцом панели дисплея, и каждый чип должен "знать", 
какой столбец он управляет, поэтому чипы пронумерованы 0 .. 31, как и столбцы. Вместо
того, чтобы хранить разные номера столбцов в каждом чипе по отдельности, мы используем небольшую хитрость.

Мы даем каждому видеочипу дополнительный 5-разрядный входной вывод с надписью chipID на его западной стороне и
добавляем соответствующий выходной вывод на его восточной стороне, но на этот раз мы добавляем 1 к числу, 
прежде чем выводить его снова. Затем, когда мы соединяем чипы в цепочку, мы обязательно
введите 0b00000 на вывод chipID самой западной микросхемы (= столбец 0), который добавляет 1 и, таким
образом, посылает сигнал 0b00001 на следующую микросхему в цепочке. Таким образом, все 32 фишки пронумерованы

+------------------------------+-------------------------------+
|Входы с западной стороны      |Выходы на восточную сторону    |
|(5-разрядные входные контакты)|(5-разрядные выходные контакты)|
+------------------------------+-------------------------------+
|             chipID           |             chipID+1          |
|             ballX            |        ballX (unchanged)      |
|             ballY            |        ballY (unchanged)      |
|            leftbatY          |       leftbatY (unchanged)    |
|           rightbatY          |      rightbatY (unchanged)    |
+------------------------------+-------------------------------+

Важно понимать, что видеочип является чисто комбинационным. Видеочип
не имеет внутреннего состояния и выдает 32-разрядный шаблон вывода,
который управляет одним столбцом панели дисплея. Этот шаблон выводится на один северный вывод.

Итак, как создается этот шаблон?
Каждый чип включает в себя схему для отображения мяча и схему для отображения одной ракетки.
Положение шара определяется входными контактами ballX и ballY. Каждый чип сравнивает свой идентификатор
чипа с ballX, и если они равны, он подсвечивает номер пикселя ballY в своем столбце дисплея.
Это простая часть комбинационной логики.

Поскольку ракетки расположены в фиксированных столбцах, мы можем "жестко подключить" их номера столбцов (3 и 28)
к видеоподсистеме. Каждый видеочип содержит две 5-битные константы: 0b00011 и
0b11100.
Эти две константы сравниваются с идентификатором чипа, поэтому видеочип с идентификатором чипа
00011 отображает левую ракетку с нижним пикселем в строке leftbatY, а видеочип
с идентификатором чипа 11100 отображает правую ракетку с нижним пикселем в строке
rightbatY. Это тоже достигается с помощью комбинационной логики.

ПРИМЕЧАНИЕ: Ни одному чипу никогда не понадобится отображать обе ракетки, но возможно, что мяч может находиться в
том же столбце, что и одна из ракеток, поэтому дизайн должен учитывать это.

---| Страница 5 |---

//Кинематический контроллер//

Задача кинематического контроллера состоит в том, чтобы перемещать мяч, обновляя его координаты, блокировать
правую ракетку, когда мяч находится в правой части экрана, и сообщать о
положении мяча и двух ракеток другим частям системы (программе и
видеоподсистеме).

Остальное выполняется другими аппаратными и программными средствами: левая ракетка управляется непосредственно
(имитируемым) джойстиком, а правая ракетка управляется (через интерфейс ввода-вывода) CdM-8
ядро, запускающее программу robot player.
Контроллер обновляет координаты и скорость мяча и сообщает о них
программе, которая использует эти значения для прогнозирования траектории полета мяча и соответствующего перемещения его ракетки.

Кинематический контроллер должен знать положение обеих ракеток, чтобы определить,
попал ли мяч в одну из них, а также отвечает за "блокировку" правой ракетки,
когда мяч находится в правой половине экрана

//Положение мяча//

Мяч перемещается по квадратному пространству, разделенному на ячейки сеткой 256 x 256, с
ячейки пронумерованы 0..255 слева направо и 0..255 снизу вверх, поэтому нижняя
левая ячейка имеет координаты 0,0. Координаты x и y шара хранятся в виде 8-
разрядных чисел без знака, и все вычисления перемещения и обновления положения выполняются на
основе этих 8-разрядных значений.

//Управление дисплеем//

Поскольку контроллер имеет положение мяча и координаты y двух ракеток,
логично использовать его для передачи их в видеоподсистему для целей отображения.
К сожалению, панель дисплея не может отображать местоположение мяча с такой большой точностью,
потому что он имеет всего 32 пикселя в поперечнике и 32 пикселя в высоту. Мы делаем так, чтобы каждый пиксель на дисплее
соответствовал множеству ячеек сетки в пространстве (фактически 64 ячейки сетки на каждый пиксель). Например,
пиксель в столбце 2 и строке 5 на экране будет использоваться для отображения шара, когда его
фактическая координата x находится между 16 и 23, а его координата y находится между 40 и 47.

Преобразование координат контроллера в номера столбцов и строк экрана легко
выполнить, отправив всего 5 наиболее значимых битов координат x и y шара в
видеоподсистема. Координаты y ракеток повсюду хранятся в виде 5-битных значений, поэтому
перевод не требуется.

//Представляющий скорость шара//

Скорость, vxy, шара имеет горизонтальную (x) составляющую, vx, и вертикальную (y)
составляющую, vy. Каждая из них представлена 3-разрядным дополнением 2 (со знаком),
что означает, что vx и vy могут принимать значения в диапазоне -4.. +3. Это очень грубая
шкала, но она достаточно хороша для наших целей.

Положительная скорость x означает, что мяч движется слева направо через пространство, и
положительная скорость y означает, что мяч движется снизу вверх. Отрицательные скорости,
конечно, означают, что мяч движется в противоположном направлении. Возможна любая комбинация vx и vy.

Каждый элемент данных, считываемый ядром CdM-8, должен быть представлен в виде 8-разрядной строки, поскольку
CdM-8 - это 8-разрядная платформа. Вместо того, чтобы дополнять каждую из двух составляющих скорости 8 битами,
мы объединяем их в одну 8-битную строку следующим образом: биты 0..2 содержат vx, биты 3..5 содержат vy, а
биты 6..7 всегда имеют значение 0.

---| Страница 6 |---

//Отражающий мяч//

Когда мяч попадает в ракетку или достигает одного из вертикальных краев пространства, он
отскакивает (отражается), отрицая vx. Когда он попадает на верхний или нижний край пространства, он
отражается отрицанием vy. Только тогда, когда мяч точно попадает в угол, нужно будет отрицать как vx, так и vy,
чтобы он отскочил.

Следует отметить, что -4 не может быть правильно отрицать, потому что для +4 не существует 3-битного
представления дополнения 2. Фактически, 3-битное дополнение 2 к -4 также равно -4, так что
скорость шара в этом направлении вообще не изменится. В этом случае вместо этого отраженное
значение скорости устанавливается равным +3.

//Внутреннее хранилище//

Для начала контроллеру нужны две пары регистров: пара 8-разрядных для координат x
и y шара и пара 3-разрядных для компонент x и y его скорости.
Он также включает в себя два 8-разрядных регистра для хранения результатов двух игроков и 5-разрядный регистр, в
который фиксируется правильное положение ракетки. Этот последний регистр используется для реализации блокировки
компьютер не может перемещать ракетку, когда мяч находится в правой половине экрана. 

Новая правая позиция ракетки может быть зафиксирована в регистре только тогда, когда мяч находится в столбце отображения,
номер которого не превышает 15.
Это все государство, которым нужно управлять. Остальная часть схемы является чисто
комбинационной.

//Расчет движения//

Траектория мяча вычисляется итеративно, шаг за шагом, с использованием локальных часов. Часы,
о которых идет речь, не имеют никакого отношения к тактовой частоте процессора, даже несмотря на моделирование Logisim
связывает все часы, используемые в дизайне, вместе. В некотором смысле существование локальных часов означает,
что контроллер сам по себе является крошечным компьютером, хотя у него нет памяти
и он вычисляет исключительно с использованием регистров. У него также нет программы как таковой, поскольку он
повторяет одну и ту же жестко запрограммированную “инструкцию” при каждом такте.

Расчет представляет собой двухфазный процесс:
Фаза 1: пошаговое движение мяча в зависимости от текущей скорости
Фаза 2: изменения скорости на основе столкновений, обнаруженных на фазе 1

Фаза 1 проста в вычислении
+-----------+
|x := x + vx|
|y := y + vy|
+-----------+
Координаты x и y используются для обозначения ячеек в виртуальном пространстве перемещения мяча. Компоненты
скорости x и y измеряются в единицах ячеек, перемещаемых за такт,
и представлены в виде 8-битных строк, причем знаковый бит, как и должно быть, смещен влево. Затем новое
положение шара может быть вычислено с помощью двух 8-разрядных сумматоров.

//Обнаружение того, когда мяч достигает края//
Очень просто определить, когда мяч столкнулся с одним из краев пространства перемещения:

*когда vx < 0, добавление его к координате x должно привести к переносу (равному 1);
если это не так, мяч только что ударился о левую стену.

*Когда vx > 0, добавление его к координате x не должно приводить
к переносу; если это произойдет, мяч только что ударился о правую стену. Аналогично, при добавлении vy к y мы можем
использовать перенос, чтобы определить, столкнулся ли мяч с потолком или полом.

На самом деле кинематический контроллер не обнаруживает столкновения с ребром. Что он
на самом деле обнаруживает, так это тот факт, что мяч находился бы вне пространства перемещения,
если бы его положение было обновлено на требуемую величину. Это явно незаконно, поэтому, когда это обнаруживается,
новая координата не фиксируется в регистре координат. Вместо этого скорость мяча в этом
измерении отрицается, чтобы заставить его ‘подпрыгивать’.

Обратите внимание, что существует два вида столкновений: горизонтальные и вертикальные.
В столкновении участвует только одна координата, другая не участвует. Конечно, если мяч попадает прямо
в угол, он может попасть в обе стены одновременно; тем не менее каждое направление столкновения
будет обрабатываться независимо.

На этапе 2 происходит обновление скорости. Если не было столкновения ни в одном из горизонтальных
(x) или вертикальном (y) измерении скорость шара остается неизменной. Если произошло
столкновение, скорость должна быть сведена на нет в этом измерении, изменив направление движения.

Как мы реализуем вышеупомянутый двухэтапный процесс? Простое решение состоит в том, чтобы использовать
обе половины тактового цикла. Когда часы высокие, координаты пересчитываются
на основе текущей скорости; когда часы низкие, скорость отражается в зависимости от
того, привело ли движение к столкновению. Это означает, что координата фиксируется
должно быть вызвано падающим краем часов, а фиксация скорости - восходящим краем.

---| Страница 7 |---

//Отбивание мяча от ракетки//

Ракетки могут влиять только на горизонтальные отражения, поскольку сами они вертикальны. Процедура
отражения почти точно такая же, как и при отражении мяча от стены. В
последнем случае мы предполагаем, что стены находятся при x = 0 и при x = 255, и используем перенос, чтобы
определить, когда мяч пытается пересечь эту границу
При обнаружении контакта с ракеткой мы выполняем несколько иные вычисления, но используем ту
же методику обнаружения при проверке выполнения. Левая ракетка находится в колонке 3 на
дисплей, что означает, что он охватывает координаты x в диапазоне 24..31. Если мы предположим, что мяч
попадет в середину ракетки, это означает, что у него будет 28 в качестве координаты x в точке
контакта.

Теперь, когда мы используем отрицательный vx для обновления положения шара (т.Е. он перемещается справа налево)
сначала мы вычитаем 28 из старого значения x, затем добавляем vx, и если есть вынос 0
, мяч, возможно, попал в ракетку (но только в том случае, если мяч имеет координату y, которая помещает его в пределах
длины ракетки).

-28 равно 0xe4, если представлено в виде 8-разрядного числа дополнения 2. Расстояние для
правой ракетки то же, 28 единиц, только теперь мяч движется в противоположном направлении, так
что расстояние положительное: 0x1c.

//Подсчет очков в игре//

Счет игрока в игре - это количество отражений мяча от вертикальной стены на
половине зоны движения другого игрока. Контроллер включает в себя два счетчика для ведения
счета. (В данном случае каждый счетчик представляет собой регистр с приращением в его обратной связи: мы используем
для него стандартный компонент Logisim).

Триггер для счетчиков очков поступает от сумматора, который реализует x +vx на этапе 1,
или, скорее, из его схемы столкновения со стеной. Каждый раз, когда обнаруживается столкновение со стеной (напомним, что
это делается путем определения того, что выполнение сумматора противоположно знаку vx), это
действует как сигнал включения для обновления счетчика баллов в следующем (с низким тактовым сигналом)
цикле фазы 2. Какой игрок получит очко, зависит исключительно от знака vx в точке столкновения.

---| Страница 8 |---

//Краткое описание проекта//

Подводя итог, можно сказать, что конструкция кинематического контроллера состоит из шести несложных частей
схемы:
• X обновление
• Обновление Y
• отражение vx
• отражение vy
• обнаружение столкновений с ракеткой
• ведение счета

Взаимосвязь между вышеуказанными частями заключается в следующем:
обновления X и Y управляют vx- и vyreflections, причем vx-отражение также определяется обнаружением столкновений с ракеткой.
Наконец, ведение счета полностью находится под контролем X-update.
Технические характеристики кинематического контроллера и двух вспомогательных микросхем, от которых он
зависит, приведены в приложении в конце этого документа

//Сопряжение игры с платформой CdM-8//

Программа, работающая на процессоре, должна знать координаты и скорость
мяча, чтобы делать прогнозы. Когда он определит желаемое положение правой
ракетки, это должно быть доступно кинематическому контроллеру.
Следовательно, интерфейс должен включать в себя один регистр ввода-вывода, в который программа запишет
y-координату правой ракетки. Это 5-разрядный регистр, который должен использовать наиболее значимые
биты из набора ввода-вывода/Odat.

Давайте подключим игровую панель к IO-3 (адрес = 0xf3) для этой игры. Один и тот же адрес может
может использоваться для считывания скорости шара vxy, упакованной, как это делает контроллер, в 8-битное слово
с неиспользуемыми 2 мбайт. В примечаниях, озаглавленных "Работа с полнофункциональной системой CDM-8", доступных
отдельно, объясняется, как совместно использовать адреса ввода-вывода.

Следует использовать еще два регистра, чтобы программа могла считывать 8-битные координаты x и y шара, скажем, IO-4 и IO-5. Ни скорость, ни координаты не требуют
регистров в интерфейсе, поскольку контроллер фиксирует их при каждом такте и утверждает
их на выводах восточной стороны. Все, что нужно сделать интерфейсу, это декодировать адрес/направление ввода-вывода
передайте и подтвердите эти значения в связке ввода-вывода/Odat.

//Программное обеспечение//

Программа должна предсказать траекторию мяча с учетом его текущего положения и скорости. Он
должен определить точку, в которой шар пересечет 28-ю вертикаль дисплея
(считая от 0), и записать ее координату y в регистр IO-3. Он должен делать это разумно
быстро, потому что, если за это время мяч дойдет до средней точки дисплея,
контроллер не скопирует содержимое ввода-вывода IO-3 на свой pin-код eatsern, и в результате правая
ракетка не будет двигаться, и мяч, скорее всего, ударится о правую стену.

Необходимость работать быстро означает, что попытка следовать аппаратному алгоритму в программном обеспечении не
даст удовлетворительных результатов, поскольку процессор слишком медленный по сравнению с контроллером.
Вместо того, чтобы имитировать контроллер, добавляя небольшие приращения к координатам и
вычисляя следующее местоположение до тех пор, пока мы не приблизимся к ракетке, мы должны вычислить конечное местоположение
мяча в точке пересечения за один шаг. Схема на следующей странице показывает, как
это можно сделать.

---| Страница 9-10 |---

Расстояние между мячом и правой ракеткой вдоль горизонтальной оси равно
224 – x (здесь и ниже мы будем измерять любые расстояния в субпикселях, чтобы масштабировать доску до
размера 256x256). Если горизонтальная скорость мяча равна vx,
то для достижения линии ракетки потребуется 224 такта контроллера (224 – x)/vx.

*картинка*

Его вертикальное смещение за это время составит (224 – x)/vx × vy. Это смещение при добавлении к
текущей координате y определяет точку пересечения на линии ракетки, в которой мяч будет
прибывать. Или, скорее, прибыл бы, если бы мы могли гарантировать, что он не столкнется с
горизонтальной стеной.

В текущем проекте ни один объект, кроме шара, никогда не движется в направлении x; это означает,
что vx имеет постоянную величину. Контроллер устанавливает vx равным -2 (110 в 3-битном
дополнении 2) при сбросе, поэтому абсолютное значение горизонтальной скорости остается на уровне 2.
С другой стороны, vy также является 3-разрядным числом, поэтому его абсолютное значение может быть не более 4.

Это означает, что мы можем легко как делить, так и умножать в программе. Мы делим на 2 на
выполняя сдвиг вправо, мы умножаем на 2 и 4, выполняя сдвиг влево; наконец,
умножение на 3 сводится к сдвигу и сложению.
В процессе “умножения” и сложения, чтобы получить смещение и конечную
точку пересечения, будут сохранены только 8 битов младшего порядка; нам нужно обратить внимание на
бит переноса. Действительно, как следует из приведенных выше диаграмм, если результат d получен без переноса
1 (слева) или с переносом 1, происходящим четное число раз (справа), d является координатой y точки пересечения.
Однако, если бит переноса был создан нечетным числом раз (например, он создается один раз на среднем рисунке),
d необходимо вычесть из 256. (Но это просто 8-битное дополнение 2.)

В приведенном выше анализе мы предположили, что вертикальная скорость vy была положительной. Ничего особенного
не меняется, когда vy<0. Разница заключается в том, что вместо подсчета количества раз,
когда при выполнении вычисления был произведен перенос 1, мы подсчитываем количество раз, когда произошел перенос 0.
Действительно, когда добавление отрицательного к положительному приводит к положительному результату (в терминах
приведенного выше рисунка: когда горизонтальная линия не пересекается), отрицательный результат приведет к переносу
из 1 (так как у него уже есть 1 в знаковом бите, и он может стать 0 только вместе с выполнением 1).

По крайней мере, программа должна быть в состоянии справиться с одним отражением. Это достаточно просто
(включает всего несколько арифметических манипуляций и тестов) и вполне достаточно, если
базовый контроллер не расширен, чтобы включать случайные колебания скорости и / или
передачу скорости от ракетки к мячу. Однако, если попытаться выполнить эти расширения, угол падения может
стать довольно крутым, и в этом случае мяч может дважды отскочить от стен
(как показано на правой диаграмме выше).

---| Страница 11 |---

//Предлагаемый ход проектирования//

1. Используйте эмулятор cocoemu для тщательной отладки вашего кода, прежде чем подключать его
к игровой панели. Вы должны использовать адреса ввода-вывода от 0xf3 до 0xf5 в качестве обычных
адресов памяти и имитировать контроллер, помещая в них константы. Таким образом,
вполне возможно полностью отладить программу прогнозирования траектории до
того, как будут построены контроллер и другие схемы.

2. Начните работу с оборудованием параллельно с программным обеспечением. Начните с создания чипа с одной
вертикальной строкой, который отображает один столбец дисплея 32x32. Чип должен
создайте 32-битный растр с нулями, или изображение шара в один пиксель на определенной высоте,
или изображение ракетки (3 последовательных пикселя на некоторой высоте), или и мяч, и
ракетка. Все будет зависеть от входных данных с восточной стороны. Используйте контакты для тщательной отладки вашей схемы.
Затем сложите 32 копии чипа вместе и посмотрите, сможете ли вы манипулировать
мячом и ракетками с помощью кеглей(?). Вы готовы приступить к созданию контроллера.

3. Очень внимательно следуйте спецификации микросхемы контроллера. Проверяйте все много раз.
Сосредоточьтесь на защелках X, Y, vx и vy и создайте рабочий прототип, который может перемещать
правильно играй в мяч. Опустите части столкновения с ракеткой и регистры очков.
Прикрепите контакты к контроллеру и установите некоторые координаты y для обеих ракеток. Нажав на
часы, посмотрите, сможете ли вы заставить мяч полететь и отразиться. Затем подключите
джойстик к входному контакту левой ракетки СЛЕВА, установите достаточно низкую частоту тика и
дайте ему поиграть со стенами и неподвижной правой ракеткой.

4. Если вы достигли этой точки, ваш контроллер в основном работает. Быстро создайте
компьютерный интерфейс и попросите вашего специалиста по программному обеспечению запустить игру. Разработайте свой собственный
однако небольшие тесты показывают, что правильная ракетка работает правильно под
управлением программы, поэтому, когда специалист по программному обеспечению намекает, что это аппаратное обеспечение не
работает, у вас может быть убедительное доказательство того, насколько они ошибаются.

УДАЧИ! =)

---| Приложение: Технические характеристики микросхемы |---

Следующие две микросхемы используются кинематическим контроллером. Каждый из них является чисто
комбинационным.
Другими словами, каждый из них действует так, как если бы это была математическая или логическая функция

Первый используется для изменения направления движения шара либо в горизонтальном, либо в
вертикальном направлении. Старая и новая скорости всегда имеют противоположный знак, но чип
не выполняет математически корректное изменение знака, поскольку предполагает, что –(-4) = 3,
что приводит к немного неправильному углу отражения шара. Это просто делает игру
более интересным.

	Chip Specification
		Name: reflect
	I/O pins
		Input: oldv(3)
		Output: newv(3)
	Combinational
		newv =
			if oldv = 0b100 then oldv’
			else oldv’+1
	End Chip Specification
	
Вторая фишка определяет, находится ли мяч в одном из рядов экрана, занятых одной из
ракеток. Это используется для определения того, соприкасались ли ракетка и мяч друг с
другом.

	Chip Specification
		Name: inrange
	I/O pins
		Input: Yball(5), Ybat(5)
		Output: shareArow
	Combinational
		shareArow = Yball = Ybat
				  ∨	Yball = (Ybat+1)
				  ∨	Yball = (Ybat+2)
	End Chip Specification

Кинематический контроллер указан здесь

	Chip Specification
		Name: kinematic_controller
		Uses combinational chips: reflect(3->3), inrange(5,5->1)
		
	I/O Pins
		Input: reset # North side
			   # The bats’ vertical coordinates (from joystick & program)
		Input: leftYin(5) # North side
		Input: rightYin(5) # West side
		
				# ball coordinates and velocity (to CdM-8 program)
				
		Output: xball(8), yball(8), vxy(8) # West side
				# scoreA, scoreB used to update scoreboard
				
		Output: scoreA(8), scoreB(8) # South side
				# number of first display column
				
		Output: zero(5) # East side
				# ball coordinates (to display)
		Output: ballX(5), ballY(5) # East side
		
				# The bats’ vertical coordinates (to display)
		Output: rightYout(5), leftYout(5) # East side
		
	Internal
		Signals: vxneg, vyneg, xrefl, yrefl
		Signals: hitA, hitB 			# one of these will be true when
										# ball passes bat of other player
		Signals: Lbcontact, Rbcontact, Bcontact
		Signals: longVX(8), longVY(8)
		
		Latches:
				 register(8) xreg,yreg  # hold current x and y coordinates
										# of the ball in 256x256 space
				 register(3) vx,vy 		# x and y components of ball velocity
				 
				 resgister(8) scA,scB 	# scores of the two players
				 resgister(5) rightYreg # holds right bat y coordinate
		 
	Combinational
		zero = 0b00000
		leftYout = leftYin 				# Left bat position passed through
										# without change
		rightYout = rightYreg 			# Right bat position taken from
										# register
		ballX = xreg.split(3:7) 		# 5 MSbs of ball coordinates
		ballY = yreg.split(3:7) 		# used to locate ball on screen
		
		vxy(0:2) = vx 					# Velocity has a 3-bit x component
		vxy(3:5) = vy 					# and a 3-bit y component
		vxy(6:7) = 0b00 				# padded to 8 bits with two 0s
		
		# Extend each 3-bit velocity to an 8-bit 2’s complement number,
		# setting the 5 MSb’s of the extended version to the sign of the
		# 3-bit version. Needed so we can add vx to x and vy to y
		longVX = vx.sign_extend(3->8,vx(2))
		longVY = vy.sign_extend(3->8,vy(2))
		
		vxneg = longVX.split(7) 				# Is x velocity negative?
		xrefl = (xreg + longVX).carry ≠ vxneg   # has the ball hit a wall?
		
		vyneg = longVY.split(7) 				# Is y velocity negative?
		yrefl = (yreg + longVY).carry ≠ vyneg 	# has the ball hit the floor
												# or ceiling?
		hitA = xrefl ∧ vxneg 					# has player A scored?
		hitB = xrefl ∧ vxneg’ 					# has player B scored?
		
		# Has ball hit right bat?
		LBcontact = ( ((xreg + 0xe4) + longVX).carry ≠ vxneg )
					∧ inrange (y, leftYin)
					
		# Has ball hit left bat?
		 RBcontact = ( ((xreg + 0x1c) + longVX).carry ≠ vxneg )
					∧ inrange(y, rightYin)
					
		 Bcontact = Lbcontact ∨ RBcontact
		 
	Behaviour
		on falling_edge of clock do:
						xreg := 					# update x-coord of ball
							if reset then 0xc0 		# x at start of game
							else xreg + longVX 		# add x-velocity to x
						enabled by:
							(xrefl’ ∧ Bcontact’) ∨ reset
							 
						yreg := # update y-coord of ball
							if reset then 0x80 		# y at start of game
							else yreg + longVY 		# add y-velocity to y
						enabled by:
							yrefl’ ∨ reset
							 
		# right bat can only move when ball is not on
		# r.h.s. of screen (column number < 16):
						rightYreg :=
							if reset then 0x0f else RightYin
						enabled by:
							ballX.split(4)’
		 
		on rising_edge of clock do:
						vx := 						# update x-velocity
							if reset then 0b110 	# initially -2
							else reflect(vx) 		# horizontal bounce
							enabled by:
							xrefl ∨ Bcontact ∨ reset
						vy := # update y-velocity
							if reset then 0b001 	# initially +1
							else reflect(vy) 		# vertical bounce
							enabled by:
							yrefl ∨ reset
						scA := scA + 1 enabled by hitA
						scB := scB + 1 enabled by hitB
	End Chip Specification